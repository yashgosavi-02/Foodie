EP-1 : Inception
-----------------


# CDN - Content Delivery Network

# CORS - Cross Origin Resource Sharing


<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

- React.CreateElement(type, prop, children);
const h1 = React.createElement('h1', {id:'heading'}, "Hello React");
- ReactDOM.createRoot(container, options);
const root = ReactDOM.createRoot(document.getElementById('root'));
- root.render(reactNode);
root.render(h1);


- Why react ? 
- Enables manipulating dom (costly opertion of browser) using Javascript

- what is attribute?
. Attributes help define the properties or behavior of the element and are specified in the opening tag of the element

- React Element : Js Object and Not a tag 

- root.render(reactElm);
root.render takes a reactElm, converts it to a tag and put it into the DOM

- Why JSX?
Creating react element was a heavy job and involved a lot of code, so we use 'JSX', making creating elements easier

--------------------------------------------------------------------------------------

EP-2 : Igniting our app
------------------------

# Adding local to github
- git init
- git branch -M main
- git add . 
- git commit -m "added _ file"
- git remote add origin [url]
- git push origin main

# what it takes to create CRA?

NPM - It is a package manager for Javascript programming language

- npm init
- package name : [name of the app]
- version : [version of the app]
- description : [what the app is about]
- entry point : [app.js / index.js / index.html]
- test command : [jest]
- git repository : [url]
- keyword : [keywords about the app]
- author : [name of the author]
- license : [license for the app]

- 'package.json' is created after initializing the npm which contains all the information about the application and what dependencies it need to work well.
- It is configuration for NPM

# Dependeny - A dependency is when a software component requires another component to work properly.
- Dev Dependency : required for development phase
- Normal Dependency : required to used in production

# Bundler - A tool that processes an application's source files into static assets for browsers. Bundlers help organize dependencies and modules, reduce file sizes, and improve website performance. [e.g : webpack, parcel, vite]

# package-lock.json : package-lock.json is a file automatically generated by npm. It is used to lock the dependency versions of packages in a project to ensure consistent installations across different environments.

# ^ (carat) :  Allows updates to patch and minor versions but not major versions
For ^1.2.3, any version >=1.2.3 and <2.0.0 will be allowed
# ~ (tilde) : Allows updates to patch versions but locks the minor and major versions.
For ~1.2.3, only versions >=1.2.3 and <1.3.0 are allowed

# node_modules : It stores all the external libraries and packages (dependencies) that your project relies on to function correctly
- transitive dependencies 

# parcel : zero config build tool for web app
# babel : Js compiler

# .gitignore : contains all the files which we want git to ignore [Never put package.json and package-lock.json]

- npx parcel index.html : executing parcel 
- It creates .parcel-cache and dist 

# .parcel-cache : Includes cached versions of parsed files, information about dependency relationships, and metadata about transformations applied to assets. Speed up builds and improve the development experience
# dist : Includes production files that are merged, minified, and optimized.

# Superpower of Parcel : 
- Development build
- Local Server
- HMR (Hot Module Replacement), File Watching Algorithm
- Caching (.parcel-cache), Faster builds
- Image optimization
- Production build (dist), Minification, Bundling, Compression
- Consistent Hashing
- Code Splitting
- Differential Bundling (Various Devices and Browser Support)
- Diagnostic and Error Handling
- Hosts app on https
- Tree Shaking (Removes Unused Code)

- Parcel manages libraries which helps in all other tasks

--------------------------------------------------------------------------------------

EP-3 : Laying the foundation
------------------------------
# creating our own npm scripts
- "start" : "parcel index.html" ==> npm start / npm run start (development)
- "build" : "parcel build index.html" ==> npm run build (production)

# React Element : JS object, which is converted to a DOM element after rendering and everything inside main root is replaced.

- React.createElement(type, prop, children)
- ReactDOM.createRoot(document.getElementById('root'));
- root.render(ReactElement);

React element => JS Object[Render] => HTML element

- Creating core react element is lengthy, so we prefer to use JSX.

# JSX - JSX stands for JavaScript XML. JSX allows us to write HTML in React. JSX makes it easier to write and add HTML in React. (It is not HTML in Js)
- It is not valid pure javascript. It is transpiled using 'babel' before it reaches the js engine to execute.
- Attributes in jsx are in camel case
- wrap the code in ( ) for multiple line writing


JSX [Babel] => React Element => JS Object[Render] => HTML element

- we can render multiple types if we wrap whole code inside '<> __ </>'

# React Component
Components are independent and reusable bits of code. They serve the same purpose as JavaScript functions, and return HTML.
- Class Based Component (legacy)
- Functional Component 

# Class Based Component
A class component must include the extends React.Component statement. The component also requires a render() method, this method returns HTML.

class Car extends React.Component {
  render() {
    return <h2>Hi, I am a Car!</h2>;
  }
}

# Functional Component 
A Function component also returns HTML, and behaves much the same way as a Class component, but Function components can be written using much less code, are easier to understand

const HeadingComponent = () => {
    return <h1 id="heading"> Namaste React!</h1>
}

const HeadingComponent = () => (
    <h1 id="heading"> Namaste React!</h1>
)

- we can render the react component using <Component1/> or Component1() or <Component1> </Component1>
- we can render one component into other by putting a component to put using <Component1/> [Component Composition]

- We can put javascript in JSX using { JS code }
- It can also handle cross site scripting attack
 
--------------------------------------------------------------------------------------

EP-4 : Talk is cheap, show me the code 
--------------------------------------

## Foodie : Food Ordering App
- Plan and Prepare your UI mock 

# Low Level Planning 
- Header
  - Logo
  - Nav Items [Home, About us, Cart]
- Body 
  - Search
  - Restaurant container
    - Restaurant card
      - Image
      - Name of Restaurant
      - Star Rating
      - Cuisine
      - Delivery time
- Footer
  - Copyright
  - Address
  - Links
  - Contact

# Making Cards Dynamic (Getting Data from an API)
- We use Props 

# Props (Properties) : We can pass it to components. We use this to pass data to components.
- [Props to components are like Arguments to function]

- <ComponentName propName="value" />
- USAGE : {prop.propName}

- props passed to component are wrapped as a object and utilized as object.propName 

- Destructuring the object 
(prop) --> ({resName, cuisine, rating deliveryTime, price})

{prop.resName} --> {resName}

-- const {resName, cuisine, rating, deliveryTime, price} = prop;

## Config-driven UI
- The layout, styles, and other properties of UI elements are defined in a configuration file or database, which can be easily modified without requiring changes to the codebase.

# API 
- https://www.swiggy.com/dapi/restaurants/list/v5?lat=12.9351929&lng=77.62448069999999&page_type=DESKTOP_WEB_LISTING

# How to get latitude and longitude from user

import React, { useState } from "react";
const GeolocationComponent = () => {
  const [location, setLocation] = useState({ latitude: null, longitude: null });
  const [error, setError] = useState(null);

  const getLocation = () => {
    if (!navigator.geolocation) {
      setError("Geolocation is not supported by your browser");
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        setLocation({
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        });
        setError(null); // Clear any previous error
      },
      (err) => {
        setError(err.message);
      }
    );
  };

  return (
    <div style={{ textAlign: "center" }}>
      <h1>Geolocation Example</h1>
      <button onClick={getLocation}>Get My Location</button>
      {location.latitude && location.longitude ? (
        <p>
          Latitude: {location.latitude}, Longitude: {location.longitude}
        </p>
      ) : (
        <p>Location not available</p>
      )}
      {error && <p style={{ color: "red" }}>Error: {error}</p>}
    </div>
  );
};
export default GeolocationComponent;

# Looping over restaurants
resList.map((data)=>{
  return <RestaurantCard resData = {data} key={data.info.id}/>
})

# Key - It help React identify which items in a list have changed, are added, or are removed. We can use index as keys but avoid its usage.
- Benefits of Using Keys:
1> Improved Performance: React can avoid unnecessary re-renders by accurately identifying which elements need to be updated.
2> Preserving State: When elements are reordered, keys ensure that the state associated with each element is preserved.
3> Preventing Bugs: In certain scenarios, not using keys can lead to unexpected behavior or bugs in your application.

--------------------------------------------------------------------------------------

EP-5 : Let's Get Hooked 
--------------------------

## Folder Structure of Production based app

- src [contains source code of app]
  - components
    - Header, Footer, Body, RestaurantCard
  - App.js
  - utils
    - constants, mockData
- index.css
- index.html

## Named and Default import and export

- Default Import and Export 

export default resList;
import resList from "path/to/file";

- Named Import and Export [used to export or import many things at once]

export {RestaurantIMG_URL, Logo_URL};
import {RestaurantIMG_URL, Logo_URL} from "path/to/file"

$ NOTE : We can do both named and default export from a file

export const component = () => {};
export const component1 = () => {};
const defaultComponent = () => {};
export default defaultComponent;

import {component, component1}, defaultComponent from "path/to/component";

## React Hooks - (Normal JS utility function)
Hooks allow us to "hook" into React features such as state and lifecycle methods.
Hooks allow function components to have access to state and other React features. Because of this, class components are generally no longer needed.
- useState() and useEffect()

@features
- Top Rated Restaurants Button 
  [We will try to filter our listofRestaurants whose rating is >= 4.0]

## Event Handlers
- onClick Event : The onclick event occurs when the user clicks on an HTML element.
Call a function when a button is clicked: <button onclick={filterFunc}>Click me</button>

$ NOTE : Data and UI layer must be consistent [Major problem solved by Frameworks like React, Angular]; Updating DOM efficiently

## JS variable 
- let listOfRes = [];

## State Variable : State variables are used to store data that can change over time, causing the component to re-render when the state is updated. 

## useState Hook

const [count, setCount] = useState(0);

The useState Hook takes an initial value as its argument and returns an array with two elements:
The first element is the current value of the state variable (e.g., count).
The second element is a function to update the state variable (e.g., setCount).

Updating the state:
To change the value of the state variable, call the setter function returned by useState (e.g., setCount(count + 1)).
Accessing the state:
The value of the state variable can be used within your component's JSX (e.g., {count}).

$ NOTE : Whenever a state variable updates react re-renders the component

## React Fiber (Find DIFF and update the DOM)

## React's Reconciliation Algorithm (React Fiber):
When React updates a component, it compares the new virtual DOM (representing the desired output) with the previous virtual DOM.
This process is called reconciliation, and it determines the minimal changes needed to update the actual DOM.

e.g : resContainer [7 cards], we apply filter which fiters the cards to [3 cards]. How this happens fastly? 

## Virtual DOM
VirtualDOM (JS OBJECT) in React is a lightweight copy of the actual DOM(a virtual representation of the DOM) used to optimize the updates on web page. So for every object that exists in the original DOM, there is an object for that in React Virtual DOM. It is exactly the same, but it does not have the power to directly change the layout of the document. 

Manipulating DOM is slow, but manipulating Virtual DOM is fast as nothing gets drawn on the screen. So each time there is a change in the state of our application, the virtual DOM gets updated first instead of the real DOM. 

## How does virtual DOM actually make things faster?
(DIFFING Algorithm)
When anything new is added to the application, a virtual DOM is created and it is represented as a tree. Each element in the application is a node in this tree. So, whenever there is a change in the state of any element, a new Virtual DOM tree is created. This new Virtual DOM tree is then compared with the previous Virtual DOM tree and make a note of the changes. After this, it finds the best possible ways to make these changes to the real DOM. Now only the updated elements will get rendered on the page again.


--------------------------------------------------------------------------------------

EP-6 : Exploring the World 
----------------------------

## Monolithc and Microservices Architecture

# Monolithc
- A single, unified application where all components (e.g., UI, business logic, and database) are tightly coupled and run as a single process.

# Microservices (Seperation of Concerns, Single Responsibility Principle)
- An application is composed of loosely coupled, independently deployable services. Each service focuses on a specific business function and communicates via APIs.

## Seperation of Concerns
- SoC is a design principle that divides an application into distinct sections, each addressing a separate concern or functionality.

## Single Responsibility Principle
- SRP states that a class, module, or microservice should have one and only one reason to change, meaning it should only focus on one responsibility.

## API : API acts as a bridge between systems, enabling them to exchange data or functionality without needing to know the details of each other's internal workings.
-----------------------------
## Fetching Data from an API

1> When our page load, make a API call, Fetch Data and Render the UI

2> When our page load, Render the UI, Make API call, Fetch the data and re-render the UI 
[Use this approach, React Render Cycles are quick and Gives better UX]

# useEffect() 
- useEffect hook in React is a powerful tool for managing side effects in functional components. Side effects are operations like fetching data, updating the DOM, subscribing to events, or setting timers, which React components perform outside rendering.

- Syntax : 

useEffect(() => {
  // Your effect logic here
  return () => {
    // Optional cleanup function
  };
}, [dependencies]);

- Fetching Data : 

  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };
    fetchData();
  }, []); // Empty array ensures fetch runs only once


# CORS - (Cross-Origin Resource Sharing) is a security mechanism implemented in web browsers to prevent unauthorized access to resources from a different origin. It is part of the Same-Origin Policy, which restricts how documents or scripts loaded from one origin can interact with resources from another.

$ Note : Optional Chaining
- Optional chaining (?.) is a feature in JavaScript that allows you to safely access deeply nested properties of an object without worrying about whether intermediate properties exist. If a property in the chain is null or undefined, the expression will short-circuit and return undefined instead of throwing an error.

$ Note : Use Shimmer UI instead of Loading Spinner
- A Shimmer UI (also known as a Skeleton Screen) is a placeholder loading animation used in modern web and mobile applications. It creates an illusion of content loading by displaying a greyed-out or animated outline of the UI components while the actual data is being fetched or processed in the background.

$ Note : Conditional Rendering 
- Ability to render different components or elements based on certain conditions.

## onChange() 
- onChange event handler is used to capture and respond to changes in the value of input fields, such as text inputs, checkboxes, radio buttons, or dropdowns. It is commonly used for managing form data and implementing controlled components.
- In React, using onChange to update state on every keypress causes the component to re-render. This behavior is expected because updating the state with setState or useState triggers a re-render of the component.


$ NOTE : Whenever state variable update, react triggers a reconciliation Cycle (re-rendering component)
