EP-1 : Inception
-----------------
# CDN - Content Delivery Network

# CORS - Cross Origin Resource Sharing

<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

- React.CreateElement(type, prop, children);
const h1 = React.createElement('h1', {id:'heading'}, "Hello React");
- ReactDOM.createRoot(container, options);
const root = ReactDOM.createRoot(document.getElementById('root'));
- root.render(reactNode);
root.render(h1);


- Why react ? 
- Enables manipulating dom (costly opertion of browser) using Javascript

- what is attribute?
. Attributes help define the properties or behavior of the element and are specified in the opening tag of the element

- React Element : Js Object and Not a tag 

- root.render(reactElm);
root.render takes a reactElm, converts it to a tag and put it into the DOM

- Why JSX?
Creating react element was a heavy job and involved a lot of code, so we use 'JSX', making creating elements easier

--------------------------------------------------------------------------------------

EP-2 : Igniting our app
------------------------

# Adding local to github
- git init
- git branch -M main
- git add . 
- git commit -m "added _ file"
- git remote add origin [url]
- git push origin main

# what it takes to create CRA?

NPM - It is a package manager for Javascript programming language

- npm init
- package name : [name of the app]
- version : [version of the app]
- description : [what the app is about]
- entry point : [app.js / index.js / index.html]
- test command : [jest]
- git repository : [url]
- keyword : [keywords about the app]
- author : [name of the author]
- license : [license for the app]

- 'package.json' is created after initializing the npm which contains all the information about the application and what dependencies it need to work well.
- It is configuration for NPM

# Dependeny - A dependency is when a software component requires another component to work properly.
- Dev Dependency : required for development phase
- Normal Dependency : required to used in production

# Bundler - A tool that processes an application's source files into static assets for browsers. Bundlers help organize dependencies and modules, reduce file sizes, and improve website performance. [e.g : webpack, parcel, vite]

# package-lock.json : package-lock.json is a file automatically generated by npm. It is used to lock the dependency versions of packages in a project to ensure consistent installations across different environments.

# ^ (carat) :  Allows updates to patch and minor versions but not major versions
For ^1.2.3, any version >=1.2.3 and <2.0.0 will be allowed
# ~ (tilde) : Allows updates to patch versions but locks the minor and major versions.
For ~1.2.3, only versions >=1.2.3 and <1.3.0 are allowed

# node_modules : It stores all the external libraries and packages (dependencies) that your project relies on to function correctly
- transitive dependencies 

# parcel : zero config build tool for web app
# babel : Js compiler

# .gitignore : contains all the files which we want git to ignore [Never put package.json and package-lock.json]

- npx parcel index.html : executing parcel 
- It creates .parcel-cache and dist 

# .parcel-cache : Includes cached versions of parsed files, information about dependency relationships, and metadata about transformations applied to assets. Speed up builds and improve the development experience
# dist : Includes production files that are merged, minified, and optimized.

# Superpower of Parcel : 
- Development build
- Local Server
- HMR (Hot Module Replacement), File Watching Algorithm
- Caching (.parcel-cache), Faster builds
- Image optimization
- Production build (dist), Minification, Bundling, Compression
- Consistent Hashing
- Code Splitting
- Differential Bundling (Various Devices and Browser Support)
- Diagnostic and Error Handling
- Hosts app on https
- Tree Shaking (Removes Unused Code)

- Parcel manages libraries which helps in all other tasks

--------------------------------------------------------------------------------------

EP-3 : Laying the foundation
------------------------------
# creating our own npm scripts
- "start" : "parcel index.html" ==> npm start / npm run start (development)
- "build" : "parcel build index.html" ==> npm run build (production)

# React Element : JS object, which is converted to a DOM element after rendering and everything inside main root is replaced.

- React.createElement(type, prop, children)
- ReactDOM.createRoot(document.getElementById('root'));
- root.render(ReactElement);

React element => JS Object[Render] => HTML element

- Creating core react element is lengthy, so we prefer to use JSX.

# JSX - JSX stands for JavaScript XML. JSX allows us to write HTML in React. JSX makes it easier to write and add HTML in React. (It is not HTML in Js)
- It is not valid pure javascript. It is transpiled using 'babel' before it reaches the js engine to execute.
- Attributes in jsx are in camel case
- wrap the code in ( ) for multiple line writing


JSX [Babel] => React Element => JS Object[Render] => HTML element

- we can render multiple types if we wrap whole code inside '<> __ </>'

# React Component
Components are independent and reusable bits of code. They serve the same purpose as JavaScript functions, and return HTML.
- Class Based Component (legacy)
- Functional Component 

# Class Based Component
A class component must include the extends React.Component statement. The component also requires a render() method, this method returns HTML.

class Car extends React.Component {
  render() {
    return <h2>Hi, I am a Car!</h2>;
  }
}

# Functional Component 
A Function component also returns HTML, and behaves much the same way as a Class component, but Function components can be written using much less code, are easier to understand

const HeadingComponent = () => {
    return <h1 id="heading"> Namaste React!</h1>
}

const HeadingComponent = () => (
    <h1 id="heading"> Namaste React!</h1>
)

- we can render the react component using <Component1/> or Component1() or <Component1> </Component1>
- we can render one component into other by putting a component to put using <Component1/> [Component Composition]

- We can put javascript in JSX using { JS code }
- It can also handle cross site scripting attack
 
--------------------------------------------------------------------------------------

EP-4 : Talk is cheap, show me the code 
--------------------------------------

## Foodie : Food Ordering App
- Plan and Prepare your UI mock 

# Low Level Planning 
- Header
  - Logo
  - Nav Items [Home, About us, Cart]
- Body 
  - Search
  - Restaurant container
    - Restaurant card
      - Image
      - Name of Restaurant
      - Star Rating
      - Cuisine
      - Delivery time
- Footer
  - Copyright
  - Address
  - Links
  - Contact

# Making Cards Dynamic (Getting Data from an API)
- We use Props 

# Props (Properties) : We can pass it to components. We use this to pass data to components.
- [Props to components are like Arguments to function]

- <ComponentName propName="value" />
- USAGE : {prop.propName}

- props passed to component are wrapped as a object and utilized as object.propName 

- Destructuring the object 
(prop) --> ({resName, cuisine, rating deliveryTime, price})

{prop.resName} --> {resName}

-- const {resName, cuisine, rating, deliveryTime, price} = prop;

## Config-driven UI
- The layout, styles, and other properties of UI elements are defined in a configuration file or database, which can be easily modified without requiring changes to the codebase.

# API 
- https://www.swiggy.com/dapi/restaurants/list/v5?lat=12.9351929&lng=77.62448069999999&page_type=DESKTOP_WEB_LISTING

# How to get latitude and longitude from user

import React, { useState } from "react";
const GeolocationComponent = () => {
  const [location, setLocation] = useState({ latitude: null, longitude: null });
  const [error, setError] = useState(null);

  const getLocation = () => {
    if (!navigator.geolocation) {
      setError("Geolocation is not supported by your browser");
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        setLocation({
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        });
        setError(null); // Clear any previous error
      },
      (err) => {
        setError(err.message);
      }
    );
  };

  return (
    <div style={{ textAlign: "center" }}>
      <h1>Geolocation Example</h1>
      <button onClick={getLocation}>Get My Location</button>
      {location.latitude && location.longitude ? (
        <p>
          Latitude: {location.latitude}, Longitude: {location.longitude}
        </p>
      ) : (
        <p>Location not available</p>
      )}
      {error && <p style={{ color: "red" }}>Error: {error}</p>}
    </div>
  );
};
export default GeolocationComponent;

# Looping over restaurants
resList.map((data)=>{
  return <RestaurantCard resData = {data} key={data.info.id}/>
})

# Key - It help React identify which items in a list have changed, are added, or are removed. We can use index as keys but avoid its usage.
- Benefits of Using Keys:
1> Improved Performance: React can avoid unnecessary re-renders by accurately identifying which elements need to be updated.
2> Preserving State: When elements are reordered, keys ensure that the state associated with each element is preserved.
3> Preventing Bugs: In certain scenarios, not using keys can lead to unexpected behavior or bugs in your application.

--------------------------------------------------------------------------------------

EP-5 : Let's Get Hooked 
--------------------------

## Folder Structure of Production based app

- src [contains source code of app]
  - components
    - Header, Footer, Body, RestaurantCard
  - App.js
  - utils
    - constants, mockData
- index.css
- index.html

## Named and Default import and export

- Default Import and Export 

export default resList;
import resList from "path/to/file";

- Named Import and Export [used to export or import many things at once]

export {RestaurantIMG_URL, Logo_URL};
import {RestaurantIMG_URL, Logo_URL} from "path/to/file"

$ NOTE : We can do both named and default export from a file

export const component = () => {};
export const component1 = () => {};
const defaultComponent = () => {};
export default defaultComponent;

import {component, component1}, defaultComponent from "path/to/component";

## React Hooks - (Normal JS utility function)
Hooks allow us to "hook" into React features such as state and lifecycle methods.
Hooks allow function components to have access to state and other React features. Because of this, class components are generally no longer needed.
- useState() and useEffect()

@features
- Top Rated Restaurants Button 
  [We will try to filter our listofRestaurants whose rating is >= 4.0]

## Event Handlers
- onClick Event : The onclick event occurs when the user clicks on an HTML element.
Call a function when a button is clicked: <button onclick={filterFunc}>Click me</button>

$ NOTE : Data and UI layer must be consistent [Major problem solved by Frameworks like React, Angular]; Updating DOM efficiently

## JS variable 
- let listOfRes = [];

## State Variable : State variables are used to store data that can change over time, causing the component to re-render when the state is updated. 

## useState Hook

const [count, setCount] = useState(0);

The useState Hook takes an initial value as its argument and returns an array with two elements:
The first element is the current value of the state variable (e.g., count).
The second element is a function to update the state variable (e.g., setCount).

Updating the state:
To change the value of the state variable, call the setter function returned by useState (e.g., setCount(count + 1)).
Accessing the state:
The value of the state variable can be used within your component's JSX (e.g., {count}).

$ NOTE : Whenever a state variable updates react re-renders the component

## React Fiber (Find DIFF and update the DOM)

## React's Reconciliation Algorithm (React Fiber):
When React updates a component, it compares the new virtual DOM (representing the desired output) with the previous virtual DOM.
This process is called reconciliation, and it determines the minimal changes needed to update the actual DOM.

e.g : resContainer [7 cards], we apply filter which fiters the cards to [3 cards]. How this happens fastly? 

## Virtual DOM
VirtualDOM (JS OBJECT) in React is a lightweight copy of the actual DOM(a virtual representation of the DOM) used to optimize the updates on web page. So for every object that exists in the original DOM, there is an object for that in React Virtual DOM. It is exactly the same, but it does not have the power to directly change the layout of the document. 

Manipulating DOM is slow, but manipulating Virtual DOM is fast as nothing gets drawn on the screen. So each time there is a change in the state of our application, the virtual DOM gets updated first instead of the real DOM. 

## How does virtual DOM actually make things faster?
(DIFFING Algorithm)
When anything new is added to the application, a virtual DOM is created and it is represented as a tree. Each element in the application is a node in this tree. So, whenever there is a change in the state of any element, a new Virtual DOM tree is created. This new Virtual DOM tree is then compared with the previous Virtual DOM tree and make a note of the changes. After this, it finds the best possible ways to make these changes to the real DOM. Now only the updated elements will get rendered on the page again.


--------------------------------------------------------------------------------------

EP-6 : Exploring the World 
----------------------------

## Monolithc and Microservices Architecture

# Monolithc
- A single, unified application where all components (e.g., UI, business logic, and database) are tightly coupled and run as a single process.

# Microservices (Seperation of Concerns, Single Responsibility Principle)
- An application is composed of loosely coupled, independently deployable services. Each service focuses on a specific business function and communicates via APIs.

## Seperation of Concerns
- SoC is a design principle that divides an application into distinct sections, each addressing a separate concern or functionality.

## Single Responsibility Principle
- SRP states that a class, module, or microservice should have one and only one reason to change, meaning it should only focus on one responsibility.

## API : API acts as a bridge between systems, enabling them to exchange data or functionality without needing to know the details of each other's internal workings.
-----------------------------
## Fetching Data from an API

1> When our page load, make a API call, Fetch Data and Render the UI

2> When our page load, Render the UI, Make API call, Fetch the data and re-render the UI 
[Use this approach, React Render Cycles are quick and Gives better UX]

# useEffect() 
- useEffect hook in React is a powerful tool for managing side effects in functional components. Side effects are operations like fetching data, updating the DOM, subscribing to events, or setting timers, which React components perform outside rendering.

- Syntax : 

useEffect(() => {
  // Your effect logic here
  return () => {
    // Optional cleanup function
  };
}, [dependencies]);

- Fetching Data : 

  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    };
    fetchData();
  }, []); // Empty array ensures fetch runs only once


# CORS - (Cross-Origin Resource Sharing) is a security mechanism implemented in web browsers to prevent unauthorized access to resources from a different origin. It is part of the Same-Origin Policy, which restricts how documents or scripts loaded from one origin can interact with resources from another.

$ Note : Optional Chaining
- Optional chaining (?.) is a feature in JavaScript that allows you to safely access deeply nested properties of an object without worrying about whether intermediate properties exist. If a property in the chain is null or undefined, the expression will short-circuit and return undefined instead of throwing an error.

$ Note : Use Shimmer UI instead of Loading Spinner
- A Shimmer UI (also known as a Skeleton Screen) is a placeholder loading animation used in modern web and mobile applications. It creates an illusion of content loading by displaying a greyed-out or animated outline of the UI components while the actual data is being fetched or processed in the background.

$ Note : Conditional Rendering 
- Ability to render different components or elements based on certain conditions.

## onChange() 
- onChange event handler is used to capture and respond to changes in the value of input fields, such as text inputs, checkboxes, radio buttons, or dropdowns. It is commonly used for managing form data and implementing controlled components.
- In React, using onChange to update state on every keypress causes the component to re-render. This behavior is expected because updating the state with setState or useState triggers a re-render of the component.


$ NOTE : Whenever state variable update, react triggers a reconciliation Cycle (re-rendering component)

--------------------------------------------------------------------------------------

EP-7 : Finding the path 
-------------------------

$ Note : Best practices for using useState()
- Always create state variable inside the body of functional component
- Put the hooks at the top, exactly below the component name
- Never create state varibles inside if-else or for-loop or function, it leads to inconsistency

$ Note : 
Case 1 > useEffect(()=>{console.log("useEffect called");}) 
If no dependency array, useEffect will be called on every render (default)

Case 2 > useEffect(()=>{console.log("useEffect called");}, [])
If empty dependency array, useEffect is called on initial render and at once.

Case 3 > useEffect(()=>{console.log("useEffect called");},[dependencyD])
If dependency array is with dependencyD, useEffect is called everytime dependencyD is updated

## Routing 
- Routing in React is typically handled using the React Router library. React Router enables navigation between views of various components in a React application, allows changing the browser URL, and keeps the UI in sync with the URL.

- Steps to add React Router 
1> npm install react-router-dom
2> import { createBrowserRouter, RouterProvider } from "react-router";
3> create a appRouter
const appRouter = createBrowserRouter([
  {
    path: "/",
    element : <App />
  },
  {
    path : "/about",
    element : <About />
  },
  {
    path : "/contact",
    element : <Contact />
  }
]);
4> Provide the appRouter to RouterProvider
root.render(<RouterProvider router={appRouter} />);


$ Note : createBrowserRouter is recommended approach to create routes for projects

# useRouteError() - Accesses the error thrown during an action, loader, or component render to be used in a route module Error Boundary.

# <Outlet/> : Renders the matching child route of a parent route or nothing if no child route matches. [It get replaced with children according the path navigated]

$ Note : Why not to use <a> to navigate in react
- The <a> tag is not commonly used for navigation within the application because it performs a full page reload by default. This behavior contradicts React's core principle of building single-page applications (SPAs), where navigation should happen without reloading the entire page.

## <Link> 
- We can use <Link> component provided by routing libraries like React Router for navigation. It prevents the default reload behavior of the <a> tag and works seamlessly with React's virtual DOM.
- <Link to="/path"> PATH </Link>


## Client Side Routing 
- Client-side routing is used in single-page applications (SPAs) where navigation is managed on the browser side without requiring a full page reload.

## Server Side Routing
- Server-side routing is the traditional approach used in multi-page applications (MPAs) where the server handles navigation by sending a new HTML file for each route.

# Dynamic routing

{
  path : "/restaurant/:resId",
  element : <RestaurantMenu />
}

$ Note : <Link> is represented to <a> in DOM.

--------------------------------------------------------------------------------------

EP-8 : Lets Get Classy 
-------------------------
## Class Based Components (Interview - legacy code)

Syntax : 

import React from "react";
class compName extends React.Component {
  render() {
    return (
      // JSX
    )
  }
}
export default compName;

Usage : 
import compName from "path/to/compName";
<compName/>

NOTE : ClassBased Component is a JavaScript class that extends React.Component which uses render method and returns JSX.

# Passing props to class based component

<compName name="yash" location="india"/>

# Receiving props and accessing them
- A single object of provided props is passed to the constructer and super method.

class compName extends React.Component  {
  constructor (props){
    super (props);
  }

  render () {
    const {name , location} = this.props;
    return (
      {name} - {location}
    )
  }
}

## local state variables in class based component

- we create state varible inside constructer using this.state = {}

constructer(props) {
  super(props);

  this.state = {
    count = 0,
    count2 = 1;
  }
}

- accessing state variable

const {count, count2} = this.state;

Note : We can creating as many as state variable we want inside this.state{} as 

- this.state{
  sv1 : defaultValue,
  sv2 : defaultValue
}

- It acts same like for the functional component state variable, a big object in backend is created for various state varibles.

- Updating State : this.setState({// update state})

this.state =  {
  count = 0,
  count1 = 1,
  count2 = 2
}

<button onClick={()=> this.setState({count : this.state.count + 1, count1 : this.state.count1 + 1})}>Increase Count</button>

Note : this.setState() updates the state variable which we wish to and it does not touch any other state variable of this.state().


## lifecycle of React Class Based Component

1> constructor() : The constructor() method is called before anything else, when the component is initiated, and it is the natural place to set up the initial state and other initial values.

2> The render() method is 'required', and is the method that actually outputs the HTML to the DOM.

3>  The componentDidMount() method is called after the component is rendered.This is where you run statements that requires that the component is already placed in the DOM.

- How class based component is mounted on webpage ?
Case 1 : When child is class based component

- child constructer
- child render

Case 2 : When both child and parent are class based component

- parent constructer
- parent render
- child constructer
- child render

case 3 : when both parent and child are class component and componentDidMount() called in both parent and child.

- parent constructer
- parent render
- child constructer
- child render
- child did mount
- parent did mount

case 4: when parent and multiple child are class component and componentDidMount().

- parent constructer
- parent render
- children1 constructer
- children1 render
- children2 constructer
- children2 render
- children1 did mount
- children2 did mount
- parent did mount 

Note : Both children's render is batched to manipulate the dom at one go making react fast.


@lifecycle : 

Render Phase: [constructor initiated and render]
- Calculates necessary changes based on updated props or state. 
- Creates a virtual DOM representation of the UI. 
- This phase is purely computational and doesn't directly manipulate the DOM. 

Commit Phase: [componentDidMount]
- Applies the changes from the virtual DOM to the real DOM. 
- Includes operations like updating DOM nodes, adding or removing elements, and calculating layout information. 
- This is where the UI visually updates on the screen. 



# Making API call : 
componentDidMount is used to make API call [acts as useEffect hook] and is executed after the completion of parent component mounting.
We generally prefer to render the component first and then make API call for better UX.
constructor(props) {
  super(props);
  this.state {
    userInfo : {
      avatar_url : dummy_url,
      name : dummy_name,
      location : dummy_location,
      contact : dummy_contact
    }
  }
}

async componentDidMount() {
  const data = await fetch(url);
  const response = await data.json();
  this.setState({
    userInfo : response
  })
}
render() {
  const {avatar_url, name, location, contact} = this.state.userInfo;
}

// Update
# componentDidUpdate() {
}
// Unmount 
# componentWillUnmount() {

}

---------------------------------------------------------------------------------------------------------------------

EP-9 : Optimizing our App 
--------------------------

# Custom Hooks
// It is not necessary to start the hook with useHookName but it is advised to avoid linting issue.

- useFetchRestMenu() hook
useFetchRestMenu takes a restaurant id as an argument and returns the menu data for that restaurant. 
This hook will be used in the Restaurant component to fetch the menu data for the selected restaurant.

- useOnlineStatus() hook
useOnlineStatus hook is used to check if online, if not show offline message.

# Optimizing our App : 
- Chunking / Code Splitting / Dynamic Bundling / Lazy Loading / On Demand Loading / dynamic import - Break your app in parts and bundle each part.

- Imagine we have a Grocery Store in the app and it contains various component. We need to seperately bundle the grocery component.

- we will load our grocery file when we navigate into the grocery section using lazy loading

import {lazy , Suspense } from "react";

const Grocery = lazy(()=> import("/path/to/grocery"));


{
  path : "/grocrey"
  element : <Suspense fallback={<Shimmer/>}><Grocery/></Suspense>
}

- fallback = {// put what will be seen until loading the <Grocery/>}

---------------------------------------------------------------------------------------------------------------------

EP-10 : Jo Dikhta hai, vo biktha hai 
------------------------------------

# Styling our App
- External CSS (index.css)
- SASS CSS
- Styled Components 
- Material UI, Bootstrap, Charka UI, Ant Design
- Tailwind CSS [We use this in our app]


# Tailwind CSS
Installation : 
Step 1> npm install -D tailwindcss postcss
        npx tailwindcss init
Step 2> .postcssrc file creation 
        { "plugins": {
          "tailwindcss": {}
          }
        }

Step 3> tailwind.config.js

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{html,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

Step 4> index.css file creation
@tailwind base;
@tailwind components;
@tailwind utilities;


