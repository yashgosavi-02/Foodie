EP-1 : Inception
-----------------


# CDN - Content Delivery Network

# CORS - Cross Origin Resource Sharing


<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

- React.CreateElement(type, prop, children);
const h1 = React.createElement('h1', {id:'heading'}, "Hello React");
- ReactDOM.createRoot(container, options);
const root = ReactDOM.createRoot(document.getElementById('root'));
- root.render(reactNode);
root.render(h1);


- Why react ? 
- Enables manipulating dom (costly opertion of browser) using Javascript

- what is attribute?
. Attributes help define the properties or behavior of the element and are specified in the opening tag of the element

- React Element : Js Object and Not a tag 

- root.render(reactElm);
root.render takes a reactElm, converts it to a tag and put it into the DOM

- Why JSX?
Creating react element was a heavy job and involved a lot of code, so we use 'JSX', making creating elements easier

--------------------------------------------------------------------------------------

EP-2 : Igniting our app
------------------------

# Adding local to github
- git init
- git branch -M main
- git add . 
- git commit -m "added _ file"
- git remote add origin [url]
- git push origin main

# what it takes to create CRA?

NPM - It is a package manager for Javascript programming language

- npm init
- package name : [name of the app]
- version : [version of the app]
- description : [what the app is about]
- entry point : [app.js / index.js / index.html]
- test command : [jest]
- git repository : [url]
- keyword : [keywords about the app]
- author : [name of the author]
- license : [license for the app]

- 'package.json' is created after initializing the npm which contains all the information about the application and what dependencies it need to work well.
- It is configuration for NPM

# Dependeny - A dependency is when a software component requires another component to work properly.
- Dev Dependency : required for development phase
- Normal Dependency : required to used in production

# Bundler - A tool that processes an application's source files into static assets for browsers. Bundlers help organize dependencies and modules, reduce file sizes, and improve website performance. [e.g : webpack, parcel, vite]

# package-lock.json : package-lock.json is a file automatically generated by npm. It is used to lock the dependency versions of packages in a project to ensure consistent installations across different environments.

# ^ (carat) :  Allows updates to patch and minor versions but not major versions
For ^1.2.3, any version >=1.2.3 and <2.0.0 will be allowed
# ~ (tilde) : Allows updates to patch versions but locks the minor and major versions.
For ~1.2.3, only versions >=1.2.3 and <1.3.0 are allowed

# node_modules : It stores all the external libraries and packages (dependencies) that your project relies on to function correctly
- transitive dependencies 

# parcel : zero config build tool for web app
# babel : Js compiler

# .gitignore : contains all the files which we want git to ignore [Never put package.json and package-lock.json]

- npx parcel index.html : executing parcel 
- It creates .parcel-cache and dist 

# .parcel-cache : Includes cached versions of parsed files, information about dependency relationships, and metadata about transformations applied to assets. Speed up builds and improve the development experience
# dist : Includes production files that are merged, minified, and optimized.

# Superpower of Parcel : 
- Development build
- Local Server
- HMR (Hot Module Replacement), File Watching Algorithm
- Caching (.parcel-cache), Faster builds
- Image optimization
- Production build (dist), Minification, Bundling, Compression
- Consistent Hashing
- Code Splitting
- Differential Bundling (Various Devices and Browser Support)
- Diagnostic and Error Handling
- Hosts app on https
- Tree Shaking (Removes Unused Code)

- Parcel manages libraries which helps in all other tasks

--------------------------------------------------------------------------------------

EP-3 : Laying the foundation
------------------------------
# creating our own npm scripts
- "start" : "parcel index.html" ==> npm start / npm run start (development)
- "build" : "parcel build index.html" ==> npm run build (production)

# React Element : JS object, which is converted to a DOM element after rendering and everything inside main root is replaced.

- React.createElement(type, prop, children)
- ReactDOM.createRoot(document.getElementById('root'));
- root.render(ReactElement);

React element => JS Object[Render] => HTML element

- Creating core react element is lengthy, so we prefer to use JSX.

# JSX - JSX stands for JavaScript XML. JSX allows us to write HTML in React. JSX makes it easier to write and add HTML in React. (It is not HTML in Js)
- It is not valid pure javascript. It is transpiled using 'babel' before it reaches the js engine to execute.
- Attributes in jsx are in camel case
- wrap the code in ( ) for multiple line writing


JSX [Babel] => React Element => JS Object[Render] => HTML element

- we can render multiple types if we wrap whole code inside '<> __ </>'

# React Component
Components are independent and reusable bits of code. They serve the same purpose as JavaScript functions, and return HTML.
- Class Based Component (legacy)
- Functional Component 

# Class Based Component
A class component must include the extends React.Component statement. The component also requires a render() method, this method returns HTML.

class Car extends React.Component {
  render() {
    return <h2>Hi, I am a Car!</h2>;
  }
}

# Functional Component 
A Function component also returns HTML, and behaves much the same way as a Class component, but Function components can be written using much less code, are easier to understand

const HeadingComponent = () => {
    return <h1 id="heading"> Namaste React!</h1>
}

const HeadingComponent = () => (
    <h1 id="heading"> Namaste React!</h1>
)

- we can render the react component using <Component1/> or Component1() or <Component1> </Component1>
- we can render one component into other by putting a component to put using <Component1/> [Component Composition]

- We can put javascript in JSX using { JS code }
- It can also handle cross site scripting attack
 
--------------------------------------------------------------------------------------

EP-4 : Talk is cheap, show me the code 
--------------------------------------

## Foodie : Food Ordering App
- Plan and Prepare your UI mock 

# Low Level Planning 
- Header
  - Logo
  - Nav Items [Home, About us, Cart]
- Body 
  - Search
  - Restaurant container
    - Restaurant card
      - Image
      - Name of Restaurant
      - Star Rating
      - Cuisine
      - Delivery time
- Footer
  - Copyright
  - Address
  - Links
  - Contact

# Making Cards Dynamic (Getting Data from an API)
- We use Props 

# Props (Properties) : We can pass it to components. We use this to pass data to components.
- [Props to components are like Arguments to function]

- <ComponentName propName="value" />
- USAGE : {prop.propName}

- props passed to component are wrapped as a object and utilized as object.propName 

- Destructuring the object 
(prop) --> ({resName, cuisine, rating deliveryTime, price})

{prop.resName} --> {resName}

-- const {resName, cuisine, rating, deliveryTime, price} = prop;

## Config-driven UI
- The layout, styles, and other properties of UI elements are defined in a configuration file or database, which can be easily modified without requiring changes to the codebase.

# API 
- https://www.swiggy.com/dapi/restaurants/list/v5?lat=12.9351929&lng=77.62448069999999&page_type=DESKTOP_WEB_LISTING

# How to get latitude and longitude from user

import React, { useState } from "react";
const GeolocationComponent = () => {
  const [location, setLocation] = useState({ latitude: null, longitude: null });
  const [error, setError] = useState(null);

  const getLocation = () => {
    if (!navigator.geolocation) {
      setError("Geolocation is not supported by your browser");
      return;
    }

    navigator.geolocation.getCurrentPosition(
      (position) => {
        setLocation({
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
        });
        setError(null); // Clear any previous error
      },
      (err) => {
        setError(err.message);
      }
    );
  };

  return (
    <div style={{ textAlign: "center" }}>
      <h1>Geolocation Example</h1>
      <button onClick={getLocation}>Get My Location</button>
      {location.latitude && location.longitude ? (
        <p>
          Latitude: {location.latitude}, Longitude: {location.longitude}
        </p>
      ) : (
        <p>Location not available</p>
      )}
      {error && <p style={{ color: "red" }}>Error: {error}</p>}
    </div>
  );
};
export default GeolocationComponent;

# Looping over restaurants
resList.map((data)=>{
  return <RestaurantCard resData = {data} key={data.info.id}/>
})

# Key - It help React identify which items in a list have changed, are added, or are removed. We can use index as keys but avoid its usage.
- Benefits of Using Keys:
1> Improved Performance: React can avoid unnecessary re-renders by accurately identifying which elements need to be updated.
2> Preserving State: When elements are reordered, keys ensure that the state associated with each element is preserved.
3> Preventing Bugs: In certain scenarios, not using keys can lead to unexpected behavior or bugs in your application.

## React's Reconciliation Algorithm:
When React updates a component, it compares the new virtual DOM (representing the desired output) with the previous virtual DOM.
This process is called reconciliation, and it determines the minimal changes needed to update the actual DOM.

